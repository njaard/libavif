/* automatically generated by rust-bindgen */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 30;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const AVIF_VERSION_MAJOR: u32 = 0;
pub const AVIF_VERSION_MINOR: u32 = 5;
pub const AVIF_VERSION_PATCH: u32 = 5;
pub const AVIF_VERSION: u32 = 505;
pub const AVIF_TRUE: u32 = 1;
pub const AVIF_FALSE: u32 = 0;
pub const AVIF_QUANTIZER_LOSSLESS: u32 = 0;
pub const AVIF_QUANTIZER_BEST_QUALITY: u32 = 0;
pub const AVIF_QUANTIZER_WORST_QUALITY: u32 = 63;
pub const AVIF_PLANE_COUNT_RGB: u32 = 3;
pub const AVIF_PLANE_COUNT_YUV: u32 = 3;
pub const AVIF_SPEED_DEFAULT: i32 = -1;
pub const AVIF_SPEED_SLOWEST: u32 = 0;
pub const AVIF_SPEED_FASTEST: u32 = 10;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type avifBool = ::std::os::raw::c_int;
pub const AVIF_PLANES_RGB: avifPlanesFlags = 1;
pub const AVIF_PLANES_YUV: avifPlanesFlags = 2;
pub const AVIF_PLANES_A: avifPlanesFlags = 4;
pub const AVIF_PLANES_ALL: avifPlanesFlags = 255;
pub type avifPlanesFlags = u32;
pub const AVIF_CHAN_R: avifChannelIndex = 0;
pub const AVIF_CHAN_G: avifChannelIndex = 1;
pub const AVIF_CHAN_B: avifChannelIndex = 2;
pub const AVIF_CHAN_Y: avifChannelIndex = 0;
pub const AVIF_CHAN_U: avifChannelIndex = 1;
pub const AVIF_CHAN_V: avifChannelIndex = 2;
pub type avifChannelIndex = u32;
extern "C" {
    pub fn avifVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avifCodecVersions(outBuffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn avifAlloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn avifFree(p: *mut ::std::os::raw::c_void);
}
pub const AVIF_RESULT_OK: avifResult = 0;
pub const AVIF_RESULT_UNKNOWN_ERROR: avifResult = 1;
pub const AVIF_RESULT_INVALID_FTYP: avifResult = 2;
pub const AVIF_RESULT_NO_CONTENT: avifResult = 3;
pub const AVIF_RESULT_NO_YUV_FORMAT_SELECTED: avifResult = 4;
pub const AVIF_RESULT_REFORMAT_FAILED: avifResult = 5;
pub const AVIF_RESULT_UNSUPPORTED_DEPTH: avifResult = 6;
pub const AVIF_RESULT_ENCODE_COLOR_FAILED: avifResult = 7;
pub const AVIF_RESULT_ENCODE_ALPHA_FAILED: avifResult = 8;
pub const AVIF_RESULT_BMFF_PARSE_FAILED: avifResult = 9;
pub const AVIF_RESULT_NO_AV1_ITEMS_FOUND: avifResult = 10;
pub const AVIF_RESULT_DECODE_COLOR_FAILED: avifResult = 11;
pub const AVIF_RESULT_DECODE_ALPHA_FAILED: avifResult = 12;
pub const AVIF_RESULT_COLOR_ALPHA_SIZE_MISMATCH: avifResult = 13;
pub const AVIF_RESULT_ISPE_SIZE_MISMATCH: avifResult = 14;
pub const AVIF_RESULT_NO_CODEC_AVAILABLE: avifResult = 15;
pub const AVIF_RESULT_NO_IMAGES_REMAINING: avifResult = 16;
pub const AVIF_RESULT_INVALID_EXIF_PAYLOAD: avifResult = 17;
pub type avifResult = u32;
extern "C" {
    pub fn avifResultToString(result: avifResult) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct avifROData {
    pub data: *const u8,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_avifROData() {
    assert_eq!(
        ::std::mem::size_of::<avifROData>(),
        16usize,
        concat!("Size of: ", stringify!(avifROData))
    );
    assert_eq!(
        ::std::mem::align_of::<avifROData>(),
        8usize,
        concat!("Alignment of ", stringify!(avifROData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifROData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avifROData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifROData>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(avifROData),
            "::",
            stringify!(size)
        )
    );
}
impl Default for avifROData {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct avifRWData {
    pub data: *mut u8,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_avifRWData() {
    assert_eq!(
        ::std::mem::size_of::<avifRWData>(),
        16usize,
        concat!("Size of: ", stringify!(avifRWData))
    );
    assert_eq!(
        ::std::mem::align_of::<avifRWData>(),
        8usize,
        concat!("Alignment of ", stringify!(avifRWData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifRWData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avifRWData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifRWData>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(avifRWData),
            "::",
            stringify!(size)
        )
    );
}
impl Default for avifRWData {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn avifRWDataRealloc(raw: *mut avifRWData, newSize: usize);
}
extern "C" {
    pub fn avifRWDataSet(raw: *mut avifRWData, data: *const u8, len: usize);
}
extern "C" {
    pub fn avifRWDataFree(raw: *mut avifRWData);
}
pub const AVIF_PIXEL_FORMAT_NONE: avifPixelFormat = 0;
pub const AVIF_PIXEL_FORMAT_YUV444: avifPixelFormat = 1;
pub const AVIF_PIXEL_FORMAT_YUV422: avifPixelFormat = 2;
pub const AVIF_PIXEL_FORMAT_YUV420: avifPixelFormat = 3;
pub const AVIF_PIXEL_FORMAT_YV12: avifPixelFormat = 4;
pub type avifPixelFormat = u32;
extern "C" {
    pub fn avifPixelFormatToString(format: avifPixelFormat) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct avifPixelFormatInfo {
    pub chromaShiftX: ::std::os::raw::c_int,
    pub chromaShiftY: ::std::os::raw::c_int,
    pub aomIndexU: ::std::os::raw::c_int,
    pub aomIndexV: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_avifPixelFormatInfo() {
    assert_eq!(
        ::std::mem::size_of::<avifPixelFormatInfo>(),
        16usize,
        concat!("Size of: ", stringify!(avifPixelFormatInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<avifPixelFormatInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(avifPixelFormatInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<avifPixelFormatInfo>())).chromaShiftX as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avifPixelFormatInfo),
            "::",
            stringify!(chromaShiftX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<avifPixelFormatInfo>())).chromaShiftY as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(avifPixelFormatInfo),
            "::",
            stringify!(chromaShiftY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifPixelFormatInfo>())).aomIndexU as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(avifPixelFormatInfo),
            "::",
            stringify!(aomIndexU)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifPixelFormatInfo>())).aomIndexV as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(avifPixelFormatInfo),
            "::",
            stringify!(aomIndexV)
        )
    );
}
extern "C" {
    pub fn avifGetPixelFormatInfo(format: avifPixelFormat, info: *mut avifPixelFormatInfo);
}
pub const AVIF_NCLX_COLOUR_PRIMARIES_UNKNOWN: avifNclxColourPrimaries = 0;
pub const AVIF_NCLX_COLOUR_PRIMARIES_BT709: avifNclxColourPrimaries = 1;
pub const AVIF_NCLX_COLOUR_PRIMARIES_BT1361_0: avifNclxColourPrimaries = 1;
pub const AVIF_NCLX_COLOUR_PRIMARIES_IEC61966_2_1: avifNclxColourPrimaries = 1;
pub const AVIF_NCLX_COLOUR_PRIMARIES_SRGB: avifNclxColourPrimaries = 1;
pub const AVIF_NCLX_COLOUR_PRIMARIES_SYCC: avifNclxColourPrimaries = 1;
pub const AVIF_NCLX_COLOUR_PRIMARIES_IEC61966_2_4: avifNclxColourPrimaries = 1;
pub const AVIF_NCLX_COLOUR_PRIMARIES_UNSPECIFIED: avifNclxColourPrimaries = 2;
pub const AVIF_NCLX_COLOUR_PRIMARIES_BT470_6M: avifNclxColourPrimaries = 4;
pub const AVIF_NCLX_COLOUR_PRIMARIES_BT601_7_625: avifNclxColourPrimaries = 5;
pub const AVIF_NCLX_COLOUR_PRIMARIES_BT470_6G: avifNclxColourPrimaries = 5;
pub const AVIF_NCLX_COLOUR_PRIMARIES_BT601_7_525: avifNclxColourPrimaries = 6;
pub const AVIF_NCLX_COLOUR_PRIMARIES_BT1358: avifNclxColourPrimaries = 6;
pub const AVIF_NCLX_COLOUR_PRIMARIES_ST240: avifNclxColourPrimaries = 7;
pub const AVIF_NCLX_COLOUR_PRIMARIES_GENERIC_FILM: avifNclxColourPrimaries = 8;
pub const AVIF_NCLX_COLOUR_PRIMARIES_BT2020: avifNclxColourPrimaries = 9;
pub const AVIF_NCLX_COLOUR_PRIMARIES_BT2100: avifNclxColourPrimaries = 9;
pub const AVIF_NCLX_COLOUR_PRIMARIES_XYZ: avifNclxColourPrimaries = 10;
pub const AVIF_NCLX_COLOUR_PRIMARIES_ST428: avifNclxColourPrimaries = 10;
pub const AVIF_NCLX_COLOUR_PRIMARIES_RP431_2: avifNclxColourPrimaries = 11;
pub const AVIF_NCLX_COLOUR_PRIMARIES_EG432_1: avifNclxColourPrimaries = 12;
pub const AVIF_NCLX_COLOUR_PRIMARIES_P3: avifNclxColourPrimaries = 12;
pub const AVIF_NCLX_COLOUR_PRIMARIES_EBU3213E: avifNclxColourPrimaries = 22;
pub type avifNclxColourPrimaries = u32;
extern "C" {
    pub fn avifNclxColourPrimariesGetValues(ancp: avifNclxColourPrimaries, outPrimaries: *mut f32);
}
extern "C" {
    pub fn avifNclxColourPrimariesFind(
        inPrimaries: *mut f32,
        outName: *mut *const ::std::os::raw::c_char,
    ) -> avifNclxColourPrimaries;
}
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_UNKNOWN: avifNclxTransferCharacteristics = 0;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_BT709: avifNclxTransferCharacteristics = 1;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_BT1361: avifNclxTransferCharacteristics = 1;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_UNSPECIFIED: avifNclxTransferCharacteristics = 2;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_GAMMA22: avifNclxTransferCharacteristics = 4;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_GAMMA28: avifNclxTransferCharacteristics = 5;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_BT601: avifNclxTransferCharacteristics = 6;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_ST240: avifNclxTransferCharacteristics = 7;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_LINEAR: avifNclxTransferCharacteristics = 8;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_LOG_100_1: avifNclxTransferCharacteristics = 9;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_LOG_100_SQRT: avifNclxTransferCharacteristics = 10;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_IEC61966: avifNclxTransferCharacteristics = 11;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_BT1361_EXTENDED: avifNclxTransferCharacteristics = 12;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_61966_2_1: avifNclxTransferCharacteristics = 13;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_SRGB: avifNclxTransferCharacteristics = 13;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_SYCC: avifNclxTransferCharacteristics = 13;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_BT2020_10BIT: avifNclxTransferCharacteristics = 14;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_BT2020_12BIT: avifNclxTransferCharacteristics = 15;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_ST2084: avifNclxTransferCharacteristics = 16;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_BT2100_PQ: avifNclxTransferCharacteristics = 16;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_ST428: avifNclxTransferCharacteristics = 17;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_STD_B67: avifNclxTransferCharacteristics = 18;
pub const AVIF_NCLX_TRANSFER_CHARACTERISTICS_BT2100_HLG: avifNclxTransferCharacteristics = 18;
pub type avifNclxTransferCharacteristics = u32;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_IDENTITY: avifNclxMatrixCoefficients = 0;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_BT709: avifNclxMatrixCoefficients = 1;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_BT1361_0: avifNclxMatrixCoefficients = 1;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_SRGB: avifNclxMatrixCoefficients = 1;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_SYCC: avifNclxMatrixCoefficients = 1;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_UNSPECIFIED: avifNclxMatrixCoefficients = 2;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_USFC_73682: avifNclxMatrixCoefficients = 4;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_BT470_6B: avifNclxMatrixCoefficients = 5;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_BT601_7_625: avifNclxMatrixCoefficients = 5;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_BT601_7_525: avifNclxMatrixCoefficients = 6;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_BT1700_NTSC: avifNclxMatrixCoefficients = 6;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_ST170: avifNclxMatrixCoefficients = 6;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_ST240: avifNclxMatrixCoefficients = 7;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_BT2020_NCL: avifNclxMatrixCoefficients = 9;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_BT2100: avifNclxMatrixCoefficients = 9;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_BT2020_CL: avifNclxMatrixCoefficients = 10;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_ST2085: avifNclxMatrixCoefficients = 11;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL: avifNclxMatrixCoefficients = 12;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL: avifNclxMatrixCoefficients = 13;
pub const AVIF_NCLX_MATRIX_COEFFICIENTS_ICTCP: avifNclxMatrixCoefficients = 14;
pub type avifNclxMatrixCoefficients = u32;
pub const AVIF_NCLX_LIMITED_RANGE: avifNclxRangeFlag = 0;
pub const AVIF_NCLX_FULL_RANGE: avifNclxRangeFlag = 128;
pub type avifNclxRangeFlag = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct avifNclxColorProfile {
    pub colourPrimaries: u16,
    pub transferCharacteristics: u16,
    pub matrixCoefficients: u16,
    pub fullRangeFlag: u8,
}
#[test]
fn bindgen_test_layout_avifNclxColorProfile() {
    assert_eq!(
        ::std::mem::size_of::<avifNclxColorProfile>(),
        8usize,
        concat!("Size of: ", stringify!(avifNclxColorProfile))
    );
    assert_eq!(
        ::std::mem::align_of::<avifNclxColorProfile>(),
        2usize,
        concat!("Alignment of ", stringify!(avifNclxColorProfile))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<avifNclxColorProfile>())).colourPrimaries as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avifNclxColorProfile),
            "::",
            stringify!(colourPrimaries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<avifNclxColorProfile>())).transferCharacteristics as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(avifNclxColorProfile),
            "::",
            stringify!(transferCharacteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<avifNclxColorProfile>())).matrixCoefficients as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(avifNclxColorProfile),
            "::",
            stringify!(matrixCoefficients)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<avifNclxColorProfile>())).fullRangeFlag as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(avifNclxColorProfile),
            "::",
            stringify!(fullRangeFlag)
        )
    );
}
pub const AVIF_RANGE_LIMITED: avifRange = 0;
pub const AVIF_RANGE_FULL: avifRange = 1;
pub type avifRange = u32;
pub const AVIF_PROFILE_FORMAT_NONE: avifProfileFormat = 0;
pub const AVIF_PROFILE_FORMAT_ICC: avifProfileFormat = 1;
pub const AVIF_PROFILE_FORMAT_NCLX: avifProfileFormat = 2;
pub type avifProfileFormat = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct avifImage {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
    pub rgbPlanes: [*mut u8; 3usize],
    pub rgbRowBytes: [u32; 3usize],
    pub yuvFormat: avifPixelFormat,
    pub yuvRange: avifRange,
    pub yuvPlanes: [*mut u8; 3usize],
    pub yuvRowBytes: [u32; 3usize],
    pub decoderOwnsYUVPlanes: avifBool,
    pub alphaPlane: *mut u8,
    pub alphaRowBytes: u32,
    pub decoderOwnsAlphaPlane: avifBool,
    pub profileFormat: avifProfileFormat,
    pub icc: avifRWData,
    pub nclx: avifNclxColorProfile,
    pub exif: avifRWData,
    pub xmp: avifRWData,
}
#[test]
fn bindgen_test_layout_avifImage() {
    assert_eq!(
        ::std::mem::size_of::<avifImage>(),
        184usize,
        concat!("Size of: ", stringify!(avifImage))
    );
    assert_eq!(
        ::std::mem::align_of::<avifImage>(),
        8usize,
        concat!("Alignment of ", stringify!(avifImage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).rgbPlanes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(rgbPlanes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).rgbRowBytes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(rgbRowBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).yuvFormat as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(yuvFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).yuvRange as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(yuvRange)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).yuvPlanes as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(yuvPlanes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).yuvRowBytes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(yuvRowBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).decoderOwnsYUVPlanes as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(decoderOwnsYUVPlanes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).alphaPlane as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(alphaPlane)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).alphaRowBytes as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(alphaRowBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).decoderOwnsAlphaPlane as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(decoderOwnsAlphaPlane)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).profileFormat as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(profileFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).icc as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(icc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).nclx as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(nclx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).exif as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(exif)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImage>())).xmp as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImage),
            "::",
            stringify!(xmp)
        )
    );
}
impl Default for avifImage {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn avifImageCreate(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        yuvFormat: avifPixelFormat,
    ) -> *mut avifImage;
}
extern "C" {
    pub fn avifImageCreateEmpty() -> *mut avifImage;
}
extern "C" {
    pub fn avifImageCopy(dstImage: *mut avifImage, srcImage: *mut avifImage);
}
extern "C" {
    pub fn avifImageDestroy(image: *mut avifImage);
}
extern "C" {
    pub fn avifImageSetProfileNone(image: *mut avifImage);
}
extern "C" {
    pub fn avifImageSetProfileICC(image: *mut avifImage, icc: *const u8, iccSize: usize);
}
extern "C" {
    pub fn avifImageSetProfileNCLX(image: *mut avifImage, nclx: *mut avifNclxColorProfile);
}
extern "C" {
    pub fn avifImageSetMetadataExif(image: *mut avifImage, exif: *const u8, exifSize: usize);
}
extern "C" {
    pub fn avifImageSetMetadataXMP(image: *mut avifImage, xmp: *const u8, xmpSize: usize);
}
extern "C" {
    pub fn avifImageAllocatePlanes(image: *mut avifImage, planes: u32);
}
extern "C" {
    pub fn avifImageFreePlanes(image: *mut avifImage, planes: u32);
}
extern "C" {
    pub fn avifImageRGBToYUV(image: *mut avifImage) -> avifResult;
}
extern "C" {
    pub fn avifImageYUVToRGB(image: *mut avifImage) -> avifResult;
}
extern "C" {
    pub fn avifFullToLimitedY(
        depth: ::std::os::raw::c_int,
        v: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avifFullToLimitedUV(
        depth: ::std::os::raw::c_int,
        v: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avifLimitedToFullY(
        depth: ::std::os::raw::c_int,
        v: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avifLimitedToFullUV(
        depth: ::std::os::raw::c_int,
        v: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct avifReformatState {
    pub kr: f32,
    pub kg: f32,
    pub kb: f32,
    pub formatInfo: avifPixelFormatInfo,
    pub usesU16: avifBool,
}
#[test]
fn bindgen_test_layout_avifReformatState() {
    assert_eq!(
        ::std::mem::size_of::<avifReformatState>(),
        32usize,
        concat!("Size of: ", stringify!(avifReformatState))
    );
    assert_eq!(
        ::std::mem::align_of::<avifReformatState>(),
        4usize,
        concat!("Alignment of ", stringify!(avifReformatState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifReformatState>())).kr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avifReformatState),
            "::",
            stringify!(kr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifReformatState>())).kg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(avifReformatState),
            "::",
            stringify!(kg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifReformatState>())).kb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(avifReformatState),
            "::",
            stringify!(kb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifReformatState>())).formatInfo as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(avifReformatState),
            "::",
            stringify!(formatInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifReformatState>())).usesU16 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(avifReformatState),
            "::",
            stringify!(usesU16)
        )
    );
}
extern "C" {
    pub fn avifPrepareReformatState(
        image: *mut avifImage,
        state: *mut avifReformatState,
    ) -> avifBool;
}
pub const AVIF_CODEC_CHOICE_AUTO: avifCodecChoice = 0;
pub const AVIF_CODEC_CHOICE_AOM: avifCodecChoice = 1;
pub const AVIF_CODEC_CHOICE_DAV1D: avifCodecChoice = 2;
pub const AVIF_CODEC_CHOICE_RAV1E: avifCodecChoice = 3;
pub type avifCodecChoice = u32;
pub const AVIF_CODEC_FLAG_CAN_DECODE: avifCodecFlags = 1;
pub const AVIF_CODEC_FLAG_CAN_ENCODE: avifCodecFlags = 2;
pub type avifCodecFlags = u32;
extern "C" {
    pub fn avifCodecName(
        choice: avifCodecChoice,
        requiredFlags: u32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avifCodecChoiceFromName(name: *const ::std::os::raw::c_char) -> avifCodecChoice;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct avifIOStats {
    pub colorOBUSize: usize,
    pub alphaOBUSize: usize,
}
#[test]
fn bindgen_test_layout_avifIOStats() {
    assert_eq!(
        ::std::mem::size_of::<avifIOStats>(),
        16usize,
        concat!("Size of: ", stringify!(avifIOStats))
    );
    assert_eq!(
        ::std::mem::align_of::<avifIOStats>(),
        8usize,
        concat!("Alignment of ", stringify!(avifIOStats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifIOStats>())).colorOBUSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avifIOStats),
            "::",
            stringify!(colorOBUSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifIOStats>())).alphaOBUSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(avifIOStats),
            "::",
            stringify!(alphaOBUSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct avifData {
    _unused: [u8; 0],
}
pub const AVIF_DECODER_SOURCE_AUTO: avifDecoderSource = 0;
pub const AVIF_DECODER_SOURCE_PRIMARY_ITEM: avifDecoderSource = 1;
pub const AVIF_DECODER_SOURCE_TRACKS: avifDecoderSource = 2;
pub type avifDecoderSource = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct avifImageTiming {
    pub timescale: u64,
    pub pts: f64,
    pub ptsInTimescales: u64,
    pub duration: f64,
    pub durationInTimescales: u64,
}
#[test]
fn bindgen_test_layout_avifImageTiming() {
    assert_eq!(
        ::std::mem::size_of::<avifImageTiming>(),
        40usize,
        concat!("Size of: ", stringify!(avifImageTiming))
    );
    assert_eq!(
        ::std::mem::align_of::<avifImageTiming>(),
        8usize,
        concat!("Alignment of ", stringify!(avifImageTiming))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImageTiming>())).timescale as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImageTiming),
            "::",
            stringify!(timescale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImageTiming>())).pts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImageTiming),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImageTiming>())).ptsInTimescales as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImageTiming),
            "::",
            stringify!(ptsInTimescales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifImageTiming>())).duration as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImageTiming),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<avifImageTiming>())).durationInTimescales as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(avifImageTiming),
            "::",
            stringify!(durationInTimescales)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct avifDecoder {
    pub codecChoice: avifCodecChoice,
    pub requestedSource: avifDecoderSource,
    pub image: *mut avifImage,
    pub imageIndex: ::std::os::raw::c_int,
    pub imageCount: ::std::os::raw::c_int,
    pub imageTiming: avifImageTiming,
    pub timescale: u64,
    pub duration: f64,
    pub durationInTimescales: u64,
    pub containerWidth: u32,
    pub containerHeight: u32,
    pub containerDepth: u32,
    pub ioStats: avifIOStats,
    pub data: *mut avifData,
}
#[test]
fn bindgen_test_layout_avifDecoder() {
    assert_eq!(
        ::std::mem::size_of::<avifDecoder>(),
        128usize,
        concat!("Size of: ", stringify!(avifDecoder))
    );
    assert_eq!(
        ::std::mem::align_of::<avifDecoder>(),
        8usize,
        concat!("Alignment of ", stringify!(avifDecoder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).codecChoice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(codecChoice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).requestedSource as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(requestedSource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).image as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).imageIndex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(imageIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).imageCount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(imageCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).imageTiming as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(imageTiming)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).timescale as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(timescale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).duration as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<avifDecoder>())).durationInTimescales as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(durationInTimescales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).containerWidth as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(containerWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).containerHeight as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(containerHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).containerDepth as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(containerDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).ioStats as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(ioStats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifDecoder>())).data as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(avifDecoder),
            "::",
            stringify!(data)
        )
    );
}
impl Default for avifDecoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn avifDecoderCreate() -> *mut avifDecoder;
}
extern "C" {
    pub fn avifDecoderDestroy(decoder: *mut avifDecoder);
}
extern "C" {
    pub fn avifDecoderRead(
        decoder: *mut avifDecoder,
        image: *mut avifImage,
        input: *mut avifROData,
    ) -> avifResult;
}
extern "C" {
    pub fn avifDecoderSetSource(decoder: *mut avifDecoder, source: avifDecoderSource)
        -> avifResult;
}
extern "C" {
    pub fn avifDecoderParse(decoder: *mut avifDecoder, input: *mut avifROData) -> avifResult;
}
extern "C" {
    pub fn avifDecoderNextImage(decoder: *mut avifDecoder) -> avifResult;
}
extern "C" {
    pub fn avifDecoderNthImage(decoder: *mut avifDecoder, frameIndex: u32) -> avifResult;
}
extern "C" {
    pub fn avifDecoderReset(decoder: *mut avifDecoder) -> avifResult;
}
extern "C" {
    pub fn avifDecoderIsKeyframe(decoder: *mut avifDecoder, frameIndex: u32) -> avifBool;
}
extern "C" {
    pub fn avifDecoderNearestKeyframe(decoder: *mut avifDecoder, frameIndex: u32) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct avifEncoder {
    pub codecChoice: avifCodecChoice,
    pub maxThreads: ::std::os::raw::c_int,
    pub minQuantizer: ::std::os::raw::c_int,
    pub maxQuantizer: ::std::os::raw::c_int,
    pub tileRowsLog2: ::std::os::raw::c_int,
    pub tileColsLog2: ::std::os::raw::c_int,
    pub speed: ::std::os::raw::c_int,
    pub ioStats: avifIOStats,
}
#[test]
fn bindgen_test_layout_avifEncoder() {
    assert_eq!(
        ::std::mem::size_of::<avifEncoder>(),
        48usize,
        concat!("Size of: ", stringify!(avifEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<avifEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(avifEncoder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifEncoder>())).codecChoice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avifEncoder),
            "::",
            stringify!(codecChoice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifEncoder>())).maxThreads as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(avifEncoder),
            "::",
            stringify!(maxThreads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifEncoder>())).minQuantizer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(avifEncoder),
            "::",
            stringify!(minQuantizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifEncoder>())).maxQuantizer as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(avifEncoder),
            "::",
            stringify!(maxQuantizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifEncoder>())).tileRowsLog2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(avifEncoder),
            "::",
            stringify!(tileRowsLog2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifEncoder>())).tileColsLog2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(avifEncoder),
            "::",
            stringify!(tileColsLog2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifEncoder>())).speed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(avifEncoder),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avifEncoder>())).ioStats as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(avifEncoder),
            "::",
            stringify!(ioStats)
        )
    );
}
impl Default for avifEncoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn avifEncoderCreate() -> *mut avifEncoder;
}
extern "C" {
    pub fn avifEncoderWrite(
        encoder: *mut avifEncoder,
        image: *mut avifImage,
        output: *mut avifRWData,
    ) -> avifResult;
}
extern "C" {
    pub fn avifEncoderDestroy(encoder: *mut avifEncoder);
}
extern "C" {
    pub fn avifImageUsesU16(image: *mut avifImage) -> avifBool;
}
extern "C" {
    pub fn avifPeekCompatibleFileType(input: *mut avifROData) -> avifBool;
}
